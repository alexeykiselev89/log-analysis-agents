"""
Утилита для построения промтов для языковой модели GigaChat.

Этот модуль формирует инструкцию для LLM и сводку классифицированных
ошибок. Инструкция детально объясняет, какие поля нужно заполнить в
ответе, и подчёркивает важность конкретных, практических рекомендаций.

Ключевые особенности промта:
* Модель получает список уникальных ошибок с нормализованным описанием,
  примерами исходных сообщений, именем класса, частотой и предварительной
  критичностью.
* От LLM требуется скорректировать критичность (если нужно), дать
  подробное описание первопричины, составить конкретный план действий
  (рекомендации) и указать, какую дополнительную информацию нужно
  собрать.
* В новой версии акцент делается на использовании деталей из логов: в
  рекомендациях и описаниях следует упоминать имена классов, методов,
  конфигурационных параметров и другие сущности, встречающиеся в
  сообщения. Общих фраз следует избегать.
"""

from typing import Iterable, List, Union

from app.agents.error_classifier import ClassifiedError, ErrorClassifier


class PromptBuilder:
    """
    Утилита для построения текста запроса (промта) для LLM.

    Метод `build_prompt` формирует инструкцию для LLM и включает
    информацию о наиболее частых ошибках, чтобы модель могла дать
    релевантные рекомендации.
    """

    @staticmethod
    def build_prompt(data: Union[dict, Iterable[ClassifiedError]]) -> str:
        """
        Создаёт текст промта для LLM на основе сгруппированных записей
        логов или последовательности объектов `ClassifiedError`.

        :param data: либо словарь, где ключом является нормализованное
            сообщение, а значением — список записей, либо итерируемая
            коллекция `ClassifiedError`.
        :return: строка с готовым промтом, которую можно отправить в LLM.
        """
        # Приводим вход к единому формату — списку объектов ClassifiedError
        if isinstance(data, dict):
            classified_errors = ErrorClassifier.classify_errors(data)  # type: ignore[arg-type]
        else:
            classified_errors = list(data)

        # Инструкции для LLM. Требуем, чтобы ассистент вернул JSON-массив
        # объектов с полями `message`, `frequency`, `criticality`,
        # `root_cause`, `recommendation` и `info_needed`. Рекомендации должны
        # быть подробными и практическими: избегать общих фраз, использовать
        # имена классов, методов, конфигурационных параметров и другие
        # сущности, присутствующие в исходном сообщении. Каждый шаг
        # рекомендаций должен описывать конкретное действие, которое может
        # выполнить инженер (например, проверить конкретный метод,
        # изменить параметр `Configuration.incompatibleImprovements` или
        # `chatx.spasibo.product.service.timeout`, написать SQL‑запрос и т. д.).
        prompt_intro = (
            "Ты опытный инженер по разработке и эксплуатации backend‑"
            "приложений (например, Java/Spring). Тебе предоставлен список "
            "уникальных ошибок из логов. Каждая запись содержит "
            "нормализованное описание ошибки, примеры исходных сообщений "
            "(включая stacktrace), имя класса, частоту и предварительную "
            "критичность.\n"
            "Твоя задача для каждой ошибки:\n"
            "1. При необходимости скорректируй оценку критичности "
            "(низкая/средняя/высокая), опираясь на частоту появления, "
            "уровень логирования и серьёзность последствий. Если ты "
            "изменяешь критичность, укажи причину в описании первопричины.\n"
            "2. Используя примеры сообщений и stacktrace, заполни поле "
            "`root_cause`: кратко опиши, какие компоненты, конфигурации, "
            "таблицы, методы или внешние сервисы являются вероятной "
            "первопричиной ошибки. При описании обязательно ссылайся на "
            "конкретные классы и параметры, упомянутые в логе.\n"
            "3. В поле `recommendation` перечисли конкретные действия для "
            "устранения проблемы. Избегай общих фраз вроде ‘проверьте логи’. "
            "Каждый пункт должен быть практическим и использовать детали из "
            "сообщения: названия классов (например, AbstractEndpointService), "
            "методов, конфигурационных параметров (например, "
            "Configuration.incompatibleImprovements, chatx.spasibo.product.service.timeout) "
            "и т. д. Опиши последовательность шагов (минимум пять), включая "
            "проверку и изменение конфигураций, исправление кода, запуск "
            "unit‑тестов, написание SQL‑запросов, анализ метрик и т. д.\n"
            "4. При возможности приведи пример кода, SQL‑запроса или "
            "конфигурации, который поможет исправить ошибку.\n"
            "5. Опиши, как проверить эффективность решения: какие тесты "
            "выполнить, какие логи или отчёты проанализировать.\n"
            "6. Если для точного диагноза недостаточно информации, заполни "
            "поле `info_needed` — перечисли, какие данные необходимо собрать "
            "(например, полный stacktrace, конкретный SQL‑запрос, содержимое "
            "конфигурационного файла, дамп таблицы и т. д.). Если всей "
            "информации достаточно, укажи null.\n\n"
            "Верни ответ строго в виде JSON‑массива без поясняющих текстов и "
            "без комментариев `//`. Каждый объект в массиве должен иметь "
            "поля:\n"
            "    \"message\" — нормализованное описание ошибки;\n"
            "    \"frequency\" — частота появления в логах (одно число);\n"
            "    \"criticality\" — окончательная оценка критичности;\n"
            "    \"root_cause\" — краткое описание первопричины;\n"
            "    \"recommendation\" — пронумерованный список шагов по "
            "исправлению;\n"
            "    \"info_needed\" — какие дополнительные данные собрать, либо null.\n\n"
            "Ниже приведён список ошибок для анализа:\n\n"
            "Важно: не добавляй комментариев (строки, начинающиеся с //) и "
            "не вводи дополнительные поля, и обязательно указывай частоту "
            "как одно целое число.\n"
        )

        # Сортируем ошибки по убыванию частоты и берём не более 10 записей
        top_errors = sorted(classified_errors, key=lambda x: x.frequency, reverse=True)[:10]

        # Формируем сводку ошибок для LLM
        logs_summary = ""
        for err in top_errors:
            example_message = err.original_message or err.message
            examples_label = "Примеры сообщений" if '\n---\n' in example_message else "Пример сообщения"
            logs_summary += (
                f"- Ошибка: {err.message}\n"
                f"  {examples_label}: {example_message}\n"
                f"  Источник (класс): {err.class_name}\n"
                f"  Частота: {err.frequency}\n"
                f"  Уровень: {err.level}\n"
                f"  Предварительная критичность: {err.criticality}\n\n"
            )

        return prompt_intro + logs_summary