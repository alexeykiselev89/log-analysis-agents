from typing import Iterable, List, Union

from app.agents.error_classifier import ClassifiedError, ErrorClassifier


class PromptBuilder:
    """
    Утилита для построения промтов для языковой модели GigaChat.

    Этот класс формирует инструкцию для LLM и сводку классифицированных
    ошибок. Для предотвращения переполнения токенов включает только
    десять наиболее частых ошибок. Инструкция требует от модели
    заполнить дополнительные поля (`root_cause` и `info_needed`) и
    выдать список конкретных действий в поле `recommendation`, чтобы
    инженер мог легко следовать рекомендациям.
    """

    @staticmethod
    def build_prompt(data: Union[dict, Iterable[ClassifiedError]]) -> str:
        """
        Создаёт текст промта для LLM на основе сгруппированных записей
        логов или последовательности объектов `ClassifiedError`.

        :param data: либо словарь, где ключом является нормализованное
            сообщение, а значением — список записей, либо итерируемая
            коллекция `ClassifiedError`.
        :return: строка с готовым промтом, которую можно отправить в LLM.
        """
        # Приводим вход к единому формату — списку объектов ClassifiedError
        if isinstance(data, dict):
            classified_errors = ErrorClassifier.classify_errors(data)  # type: ignore[arg-type]
        else:
            classified_errors = list(data)

        # Инструкции для LLM. Мы требуем, чтобы ассистент вернул JSON-массив
        # объектов с полями `message`, `frequency`, `criticality`,
        # `root_cause`, `recommendation` и `info_needed`. `recommendation`
        # должен быть нумерованным списком минимум из пяти шагов. Также
        # объясняем, что критичность следует корректировать только при
        # наличии оснований (частота, уровень лога).
        prompt_intro = (
            "Ты опытный инженер по разработке и эксплуатации backend‑"
            "приложений (например, Java/Spring). Тебе предоставлен список "
            "уникальных ошибок из логов. Каждая запись содержит "
            "нормализованное описание ошибки, примеры исходных сообщений "
            "(включая stacktrace), имя класса, частоту и предварительную "
            "критичность.\n"
            "Твоя задача для каждой ошибки:\n"
            "1. При необходимости скорректируй оценку критичности "
            "(низкая/средняя/высокая), опираясь на частоту появления, "
            "уровень логирования и серьёзность последствий. Если ты "
            "изменяешь критичность, укажи причину в описании первопричины.\n"
            "2. Используя примеры сообщений и stacktrace, заполни поле "
            "`root_cause`: кратко опиши, какие компоненты, конфигурации, "
            "таблицы, методы или внешние сервисы являются вероятной "
            "первопричиной ошибки.\n"
            "3. В поле `recommendation` перечисли конкретные действия для "
            "устранения проблемы, в виде пронумерованного списка (1., 2., 3., …). "
            "Укажи как минимум пять последовательных шагов: какие классы, методы, "
            "таблицы, поля, индексы или параметры конфигурации нужно проверить, "
            "изменить или создать; какие команды или SQL‑запросы выполнить; какие "
            "логи, метрики или конфигурации дополнительно изучить.\n"
            "4. При возможности приведи пример кода, SQL‑запроса или "
            "конфигурации, который поможет исправить ошибку.\n"
            "5. Опиши, как проверить эффективность решения: какие тесты "
            "выполнить, какие логи или отчёты проанализировать.\n"
            "6. Если для точного диагноза недостаточно информации, заполни поле "
            "`info_needed` — перечисли, какие данные необходимо собрать (например, "
            "полный stacktrace, конкретный SQL‑запрос, конфигурационный файл, "
            "дамп таблицы и т. д.). Если всей информации достаточно, укажи null.\n\n"
            "Верни ответ строго в виде JSON‑массива без поясняющих текстов и без "
            "комментариев `//`. Каждый объект в массиве должен иметь поля:\n"
            "    \"message\" — нормализованное описание ошибки;\n"
            "    \"frequency\" — частота появления в логах (одно число);\n"
            "    \"criticality\" — окончательная оценка критичности;\n"
            "    \"root_cause\" — краткое описание первопричины;\n"
            "    \"recommendation\" — пронумерованный список шагов по исправлению;\n"
            "    \"info_needed\" — какие дополнительные данные собрать, либо null.\n\n"
            "Пример структуры ответа:\n"
            "[\n"
            "  {\n"
            "    \"message\": \"duplicate key value violates unique constraint ...\",\n"
            "    \"frequency\": 42,\n"
            "    \"criticality\": \"высокая\",\n"
            "    \"root_cause\": \"Отсутствие уникального индекса на поле appeal_id в таблице appeals_dzo, что приводит к конфликтам при вставке.\",\n"
            "    \"recommendation\": \"1. Проверьте существование уникального индекса на appeals_dzo.appeal_id; 2. При необходимости создайте индекс; 3. Проанализируйте код saveAppeal() на предмет проверки дубликатов; 4. Дополнительно логируйте идентификаторы при сохранении; 5. Проверьте связанные таблицы на наличие неконсистентных данных.\",\n"
            "    \"info_needed\": null\n"
            "  },\n"
            "  ...\n"
            "]\n\n"
            "Ниже приведён список ошибок для анализа:\n\n"
            "Важно: не добавляй комментариев (строки, начинающиеся с //) и "
            "не вводи дополнительные поля, и обязательно указывай частоту как "
            "одно целое число.\n"
        )

        # Сортируем ошибки по убыванию частоты и берём не более 10 записей
        top_errors = sorted(classified_errors, key=lambda x: x.frequency, reverse=True)[:10]

        # Формируем сводку ошибок для LLM
        logs_summary = ""
        for err in top_errors:
            # Если оригинальное сообщение состоит из нескольких примеров, используем множественное число
            example_message = err.original_message or err.message
            if '\n---\n' in example_message:
                examples_label = "Примеры сообщений"
            else:
                examples_label = "Пример сообщения"
            # Добавляем сведения об ошибке: нормализованное сообщение, примеры, класс,
            # частоту, уровень логирования и предварительную критичность
            logs_summary += (
                f"- Ошибка: {err.message}\n"
                f"  {examples_label}: {example_message}\n"
                f"  Источник (класс): {err.class_name}\n"
                f"  Частота: {err.frequency}\n"
                f"  Уровень лога: {err.level}\n"
                f"  Предварительная критичность: {err.criticality}\n\n"
            )

        return prompt_intro + logs_summary